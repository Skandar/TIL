# Как работает Chrome?

При загрузке браузер запускает процессы и потоки. Процессы отвечают за выполнения работы всего приложения или какой-то его части. Внутри процесса браузер может запустить потоки, но это не обязательно. Потоки выполняют часть работы процесса.

**Примеры процессов:**

- Браузерный - отвечает за отображение "хрома" (адресной строки, закладов, кнопок вперёд и назад), так же отвечает за обработку скрытых, привилегированных частей браузера, таких как сетевые запросы и доступ к файловой системе.
- Рендер (Renderer) - контролирует всё внутри вкладки.
- Plugin - контролирует работу плагинов.
- GPU - обрабатывает GPU задачи изолированно от других процессов.

Несколько процессов могут общаться используя Inter Process Communication (IPC).

## Мультипроцессная архитектура

Браузеры имеют мультипроцессную архитектуру.

**Преимущества:**

- При падении одного рендер процесса, перестаёт работать только одна вкладка, а остальные функционируют нормально.
- Безопасность. Операционная система предоставляет возможность ограничивать привилегии процессов, а браузер может поместить процесс в песочницу.

**Недостатки:**

- Требует больше оперативной памяти. Для сохранения памяти Хром имеет лимит одновременно запущенных процессов. Лимит зависит от количества оперативной памяти и мощности процессора. Когда лимит превышен, хром перемещает все вкладки с одним и тем же сайтом в один процесс.

## Сервисы

Разные части браузер разбиты на сервисы. На мощном железу сервисы могут выполняться несколькими процессами, а на слабом железе, группироваться в один процесс.

## Изоляция сайтов

Для каждой вкладки и cross-site iframe создаётся отдельный рендер процесс.

## Навигация

При вводе URL в адресную строку браузер проходит такие этапы:

1. Обработка ввода. В браузерном процессе UI поток находит адресную строку, парсит введённое значение и определяет, что это, поисковый запрос или URL.
2. Начало навигации. Когда пользователь нажимает Enter (или на ссылку на странице), если это уже открытый сайт выполняется проверка был ли назначен обработчик события `beforeunload`. Если был, появляется алерт "Leave this site?". После этого, если выполняется навигация на новый ресурс, то создаётся новый рендер процесс. UI поток инициирует сетевой запрос, что бы получить контент сайта. Показывается спинер во вкладке и сетевой поток выполняет DNS запрос и производит TSL соединение для запроса. В этом момент сетевой поток может получить от сервера ответ, с HTTP заголовком `301`. В этом случае сетевой поток связывается с UI потоком и сообщает, что сервер запрашивает редирект. После этого инициируется сетевой запрос с новый URI. Так же на этом этапе перед тем как выполнить запрос сетевой поток выполняет проверку зарегистрированных сервисворкеров, если на этом URL зарегистрирован сервисворкер, то UI поток ищет рендер процесс для выполнения кода сервисворкера. Сервис воркер может загрузить данные из кэша, таким образом отменить необходимость в сетевых запросах или он может запросить новые ресурсы с сети.
3. Чтение ответа. Определяется `Content-Type` в ответе. Если это HTML, то данные передаются в рендер процесс, а если файл (например, zip), в менеджер загрузок. Так же на этом этапе выполняется проверки безопасности. Если известно, что это вредоносный сайт, то выдаётся предупреждение. Дополнительно выполняется Cross Origin Read Blocking (CORB) проверка, для того что бы быть уверенным, что конфиденциальные cross-site данные не попадают в рендер процесс.
4. После того как все проверки выполнены, и сетевой процесс уверен, что браузер должен выполнить навигацию на запрашиваемый сайт, сетевой запрос сообщает UI потоку, что данные готовы. UI поток ищет рендер процесс что бы продолжить рендер веб-страницы.  После того как UI поток отправил URL запрос сетевому потоку (2 этап), он пытается параллельно сетевому запросу найти или начать рендер процесс.
5. Выполнение навигации. Данные сайта и рендер процесс готовы, браузерный процесса используя IPC отправляет данные в рендер процесс. После того как рендер процесс подтвердил что данные передались, навигация считается завершённой и начинается фаза загрузки документа. Адресная строка обновляется, переход записывается в историю.
6. Загрузка ресурсов. После окончания навигации рендер процесс загружает ресурсы и рендерит страницу. После того как рендер процесс "закончил" рендер он посылает IPC назад в брузерный процесс (это совершается после того как все события `onload` на странице сработали). После этого UI поток перестаёт отображать спинер.

## Рендер процесс

Рендер процесс отвечает за всё что происходит во вкладке браузера. Для того что бы отобразить страницу в рендер процессе выполняет следующие действия:

### 1. Парсинг

Основной поток (main thread) парсит HTML и превращает его в DOM. При нахождении во время парсинга ссылок на сторонние ресурсы скачивает их. CSS и JS являются блокирующими ресурсами. JS блокирует основной поток, т.к. предполагается что в нём может быть код меняющий DOM. Для того что бы JS не блокировал парсинг HTML, тегу `<script>` можно указать атрибут `async` или `defer`, тогда скрипт будет загружаться и выполняться асинхронно.

### 2. Вычисление стилей

Парсится CSS и формируется CSSOM. Определяется каким DOM нодам присваиваются какие стили.

### 3. Layout

Определяет форму каждого видимого элемента и его положение на странице. Формируется дерево расположения элементов (layout tree).

### 4. Отрисовка (Paint)

Определяет в какой последовательности нужно отрисовывать элементы. Основной поток проходит по дереву расположения элементов и создаёт paint records. Paint record - это "заметка" о процессе отрисовки: "сначала фон, потом текст, потом прямоугольник".

### 5. Композиция (Compositing)

Разные части страницы разделяются на слои, растрируются (информация преобразуется в пиксели) по отдельности и объединяются в единую страницу в отдельном потоке (композитор потоке (compositor thread)).

Для того что бы определить какой элемент должен быть на каком слое, основной поток проходит по дереву расположения элементов и формирует дерево слоёв (layer tree). Браузеру можно подсказать какой элемент должен быть на отдельном слое используя CSS свойство `will-change` для этого элемента. Не стоит злоупотреблять этим свойством, т.к. это может привести к ухудшению производительности.

Слои могут быть большими, размером как вся страница, поэтому композитор поток разделяет их на плитки и посылает их в растровый поток. Растровый поток хранит каждую плитку в GPU памяти.

Композитор поток может выставлять приоритеты растер потокам, так, например, слои которые находятся в области просмотра браузера (или рядом) могут быть растрированы раньше. У слоёв есть плитки для разных разрешений, которые могут быть использованы при зуме.
После того как плитки растрированы, композитор поток собирает информацию о плитке в **draw quads**, для того что бы создать **композитор фрейм** (compositor frame).

**Draw quads** - структура хранящая информацию о местоположении плитки в памяти и позиции где её нужно отрисовать на странице.

**Композитор фрейм** - коллекция draw quads, которые представляют фрейм страницы.


После этого композитор фрейм отправляется в браузерный процесс через IPC. На этом этапе можно добавить другой композитор фрейм из UI потока для изменения UI браузера или из рендер процессов расширений браузера. Эти композитор фреймы отправляются в GPU для отображения на экране.

При композиции слоёв не используется основной поток и композитор потоку не нужно ждать вычисления стилей или выполнения JS'a. Исходя из этого для производительных анимаций рекомендуется анимировать только CSS свойства, которые приводят лишь к композиции слоёв (opacity, translate, rotate, scale), в противном случае, будут пересчитываться layout или отрисовка, и это приведёт к задействованию основного потока.

## Ссылки

- [Inside look at modern web browser (part 1)](https://developers.google.com/web/updates/2018/09/inside-browser-part1)
- [Inside look at modern web browser (part 2)](https://developers.google.com/web/updates/2018/09/inside-browser-part2)
- [Inside look at modern web browser (part 3)](https://developers.google.com/web/updates/2018/09/inside-browser-part3)
