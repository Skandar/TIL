# Promise

Объект Promise создан для упрощения работы с асинхронными операциями.

При создании нового промиса указывается колбэк, который сразу и выполняется. Колбэк промиса имеет в аргументах 2 функции:

- `resolve(value)` - работа завершилась успешно;
- `reject(error)` - во время работы произошла ошибка.

 Одну из них обязательно нужно выполнить внутри колбэка. Исполняется только первая найденная функция, остальные игнорируются.

```js
const promise = new Promise((resolve, reject) => {
  // ...
  setTimeout(() => {
    resolve('Длительная операция закончена') // или `reject(new Error('...'))` при ошибке
  }, 3000);
})
```

Созданный экземпляр промиса имеет такие свойства:

- `state` - текущее состояние промиса. Может быть:
  - `pending` - промис создан, но пока не разрешился;
  - `fulfilled` - промис успешно разрешился;
  - `rejected` - промис разрешился ошибкой.
- `result` - результат выполнения промиса. Сначала `undefined`, далее может измениться на `value` при вызове `resolve(value)` или на `error` при вызове `reject(error)`.

## Методы

- `Promise.prototype.then` - перехватывает результат промиса, выполняется после того как промис разрешится. Первый аргумент обрабатывает ситуацию когда промис переходит в состояние `fulfilled` (выполнился успешно), а второй когда состояние `rejected` (выполнился с ошибкой).

  Синтаксис:

  ```js
  promise.then(
    function(result) { /* обработает успешное выполнение */ },
    function(error) { /* обработает ошибку */ }
  );
  ```

- `Promise.prototype.catch` - метод для обработки ошибки. Имеет единственный аргумент, ошибку. То же самое, что `.then(null, function(error) { ... })`

  Синтаксис:

  ```js
  promise.catch(error => { ... }); // обрабатывает ошибку
  ```

- `Promise.prototype.finally` - код выполняемый при любом сценарии разрешения промиса. Это не то же самое что метод `.then`. Имеет такие особенности:
  - не имеет аргументов;
  - пропускает результат разрешения промиса дальше, к другим обработчикам.

  Синтаксис:

  ```js
  new Promise((resolve, reject) => { ... }
    .finally(() => { /* выполняется не зависимо от результата разрешения промиса */ })
    .then(result => { ... })
  ```

- `Promise.resolve(value)` - создаёт промис, который разрешается `value`. Когда `value` является промисом, возвращает его без изменений. Удобно когда нужно быть точно уверенным, что `value` является промисом.
- `Promise.reject(error)` - отклоняет промис со значением `error`.
- `Promise.all(iterable)` - принимает массив (или другую итерируемую структуру данных) и ждёт пока все промисы успешно разрешатся, после чего возвращает массив результатов. В случае ошибки происходит `reject(error)` и возвращается `error`.
- `Promise.allSettled(iterable)` - после разрешения всех промисов, возвращает массив с результатами в виде `{ status: "fulfilled", value: ... }` для успешно разрешённых промисов и `{ status: "rejected",  reason: ... }` для промисов разрешившихся ошибкой.
- `Promise.race(iterable)` - ждёт первый разрешившийся промис и возвращает результат.
- `Promise.any(iterable)` - ждёт первый **успешно** разрешившийся промис и возвращает результат. Если успешно разрешённых промисов нет, возвращает `AggregateError` со списков всех ошибок.

## Ссылки

[MDN. Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
[Промисы, async/await](https://learn.javascript.ru/async)
[Exploring ES6. Promises for asynchronous programming](https://exploringjs.com/es6/ch_promises.html)
